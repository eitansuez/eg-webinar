{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Here you will find a number of scenarios that can assist you in exploring the Envoy Gateway project.</p> <p>These scenarios are an adaptation of a selection of the tasks documented on the Envoy Project's web site.</p> <p>After working through these scenarios, explore further by visiting the Envoy Gateway documentation proper.</p> <p>Sincerely,</p> <p>-- Eitan Suez &amp; the team @ Tetrate</p>"},{"location":"auth/","title":"Authentication","text":"<p>Envoy Gateway supports a number of distinct authentication mechanisms, including JWT, OIDC, external authorization, and basic auth.</p> <p>In this exercise, we keep things simple and demonstrate basic auth.</p> <p>Once more, we are dealing with a feature that is outside the current Gateway API specification, and so we use a SecurityPolicy attachment against the route we wish to protect, which in this case is the <code>httpbin</code> route.</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: SecurityPolicy\nmetadata:\n  name: httpbin-basicauth\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  basicAuth:\n    users:\n      name: httpbin-users\n</code></pre> <p>The value of the <code>name</code> field on line 13 refers a secret containing an <code>htpasswd</code> file.</p> <ol> <li> <p>Create the htpasswd file:</p> <pre><code>htpasswd -cs .htpasswd eitan\n</code></pre> </li> <li> <p>Create the secret from the generated file:</p> <pre><code>kubectl create secret generic httpbin-users --from-file=.htpasswd\n</code></pre> </li> <li> <p>Apply the security policy:</p> <pre><code>kubectl apply -f auth/basic.yaml\n</code></pre> </li> </ol>"},{"location":"auth/#test-it","title":"Test it","text":"<p>Access the application, or:</p> <ol> <li> <p>Request without credentials return a 401 (Forbidden)</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl --insecure --head https://httpbin.esuez.org/\n</code></pre> <pre><code>curl --insecure --head https://httpbin.esuez.org/ \\\n  --resolve httpbin.esuez.org:443:$GATEWAY_IP\n</code></pre> <pre><code>HTTP/2 401\ncontent-length: 58\ncontent-type: text/plain\ndate: Tue, 07 May 2024 23:18:11 GMT\n</code></pre> </li> <li> <p>Authenticated requests succeed:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl --insecure --head --user eitan:correctpassword https://httpbin.esuez.org/\n</code></pre> <pre><code>curl --insecure --head --user eitan:correctpassword https://httpbin.esuez.org/ \\\n  --resolve httpbin.esuez.org:443:$GATEWAY_IP\n</code></pre> <pre><code>HTTP/2 200\nserver: gunicorn/19.9.0\ndate: Tue, 07 May 2024 23:18:20 GMT\ncontent-type: text/html; charset=utf-8\ncontent-length: 9593\naccess-control-allow-origin: *\naccess-control-allow-credentials: true\n</code></pre> </li> <li> <p>Bad credentials produce a 401 (Forbidden):</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl --insecure --head --user eitan:wrongpassword https://httpbin.esuez.org/\n</code></pre> <pre><code>curl --insecure --head --user eitan:wrongpassword https://httpbin.esuez.org/ \\\n  --resolve httpbin.esuez.org:443:$GATEWAY_IP\n</code></pre> <pre><code>HTTP/2 401\ncontent-length: 66\ncontent-type: text/plain\ndate: Tue, 07 May 2024 23:18:23 GMT\n</code></pre> </li> </ol>"},{"location":"auth/#inspect-the-proxy-configuration","title":"Inspect the Proxy configuration","text":"<p>We can look at the Envoy listeners configuration and inspect the HTTP connection manager's filter chain to confirm that the basic auth filter is installed.</p> <pre><code>egctl config envoy-proxy listener -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default \\\n  -o yaml | bat -l yaml\n</code></pre> <p>Here is sanitized output for the HTTPS listener:</p> <pre><code>...\nfilterChains:\n- filterChainMatch:\n    serverNames:\n    - httpbin.esuez.org\n  filters:\n  - name: envoy.filters.network.http_connection_manager\n    typedConfig:\n      httpFilters:\n      - name: envoy.filters.http.basic_auth_httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\n        disabled: true\n        typedConfig:\n          '@type': type.googleapis.com/envoy.extensions.filters.http.basic_auth.v3.BasicAuth\n          users:\n            inlineBytes: W3JlZGFjdGVkXQ==\n      - name: envoy.filters.http.ratelimit\n        typedConfig:\n          '@type': type.googleapis.com/envoy.extensions.filters.http.ratelimit.v3.RateLimit\n          domain: default/eg/https\n          enableXRatelimitHeaders: DRAFT_VERSION_03\n          rateLimitService:\n            grpcService:\n              envoyGrpc:\n                clusterName: ratelimit_cluster\n            transportApiVersion: V3\n      - name: envoy.filters.http.router\n        typedConfig:\n          '@type': type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\n          suppressEnvoyHeaders: true\n  ...\n</code></pre> <p>The basic auth filter is configured at the level of the listener, but disabled there. Since the authentication rule is applied at the route level, we need to look at the route.</p> <pre><code>egctl config envoy-proxy route -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default \\\n  -o yaml | bat -l yaml\n</code></pre> <p>Here is the salient part of the output:</p> <pre><code>envoy-gateway-system:\n  envoy-default-eg-e41e7b31-c7657fcf5-tmsdt:\n    dynamicRouteConfigs:\n    ...\n    - routeConfig:\n        name: default/eg/https\n        virtualHosts:\n        - domains:\n          - httpbin.esuez.org\n          name: default/eg/https/httpbin_esuez_org\n          routes:\n          - match:\n              prefix: /\n            name: httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\n            route:\n              cluster: httproute/default/httpbin/rule/0\n              rateLimits:\n              ...\n            typedPerFilterConfig:\n              envoy.filters.http.basic_auth:\n                '@type': type.googleapis.com/envoy.extensions.filters.http.basic_auth.v3.BasicAuthPerRoute\n                users:\n                  inlineBytes: W3JlZGFjdGVkXQ==\n</code></pre>"},{"location":"ext-authz/","title":"External Authorization","text":"<p>This scenario demonstrates how Envoy's external authorization filter can be applied to an HttpRoute.</p>"},{"location":"ext-authz/#context","title":"Context","text":"<p>We will use the Ext Authz service sample from the Istio distribution.</p> <p>Deploy the service:</p> <pre><code>kubectl apply -f ext-authz/ext-authz.yaml\n</code></pre>"},{"location":"ext-authz/#the-contract","title":"The contract","text":"<p>The service you just deployed will allow (200) any request bearing the header <code>x-ext-authz: allow</code>.</p> <p>The absence of the header, or the header with a value other than <code>allow</code> will be denied (403).</p>"},{"location":"ext-authz/#instructions","title":"Instructions","text":"<p>Make sure that the <code>httpbin</code> service is deployed, and a simple route is defined from the gateway to the service.</p> <p>Review the following security policy:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: SecurityPolicy\nmetadata:\n  name: ext-authz-policy\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  extAuth:\n    http:\n      backendRefs:\n      - group: \"\"\n        kind: Service\n        name: ext-authz\n        port: 8000\n    headersToExtAuth:\n    - x-ext-authz\n</code></pre> <p>Apply the policy:</p> <pre><code>kubectl apply -f ext-authz/security-policy.yaml\n</code></pre> <p>Send a test request:</p> <pre><code>curl -v -H \"x-ext-authz: allow\" http://httpbin.esuez.org/json --resolve httpbin.esuez.org:80:$GATEWAY_IP\n</code></pre> <p>The above request should succeed.</p> <p>Absence of the header, or header value that is not \"allow\" will return a 403.</p>"},{"location":"observability/","title":"Observability","text":"<p>The following content is distilled from the Envoy Gateway docs.</p> <p>The objective is to collect Gateway metrics with Prometheus and expose them through Grafana dashboards.</p>"},{"location":"observability/#generate-a-load","title":"Generate a load","text":"<pre><code>while true; do\n  curl --head https://httpbin.esuez.org/json --resolve httpbin.esuez.org:443:$GATEWAY_IP\n  sleep 0.5\ndone\n</code></pre>"},{"location":"observability/#deploy-observability-tools","title":"Deploy Observability tools","text":"<p>The following command will deploy all necessary observability tools to the <code>monitoring</code> namespace, including prometheus and grafana:</p> <pre><code>helm install eg-addons oci://docker.io/envoyproxy/gateway-addons-helm \\\n  --version v1.1.0 \\\n  --set opentelemetry-collector.enabled=true \\\n  -n monitoring --create-namespace\n</code></pre> <p>Confirm that Prometheus, Grafana, and other observability tools (loki, tempo, fluent-bit) are running in the <code>monitoring</code> namespace.</p>"},{"location":"observability/#monitor-envoy","title":"Monitor Envoy","text":"<p>A LoadBalancer type service is already defined for Grafana in the <code>monitoring</code> namespace.</p> <p>If you're running locally or don't have a public IP address associated with the service, you can use the <code>kubectl port-forward</code> command:</p> <pre><code>kubectl -n monitoring port-forward svc/grafana 3000:80\n</code></pre> <p>Visit localhost:3000 and login to grafana using <code>admin:admin</code>.</p> <ul> <li>The prometheus data source is already configured.</li> <li>Several Envoy monitoring dashboards have already be imported and can be seen in the <code>envoy-gateway</code> folder.</li> </ul> <p>You will find four distinct dashboards:</p> <ul> <li>envoy global: monitor envoy proxy</li> <li>envoy gateway global: monitor envoy gateway</li> <li>envoy clusters: envoy proxy metrics with cluster/service-level granularity</li> <li>resources monitor: monitor resource utilization of Envoy and Envoy Gateway</li> </ul>"},{"location":"observability/#ad-hoc-query-metrics","title":"Ad-hoc query metrics","text":"<p>A LoadBalancer type service is already defined for Prometheus in the <code>monitoring</code> namespace.</p> <p>If you're running locally or don't have a public IP address associated with the service, you can use the <code>kubectl port-forward</code> command:</p> <pre><code>kubectl -n monitoring port-forward svc/prometheus 9090:80\n</code></pre> <p>Visit localhost:9090 and look for the retry metric from the retries lab:</p> <pre><code>envoy_cluster_upstream_rq_retry{envoy_cluster_name=\"httproute/default/httpbin/rule/0\"}\n</code></pre>"},{"location":"oidc/","title":"OIDC with Okta","text":"<p>We wish to protect the <code>httpbin</code> application with OpenID Connect authentication.</p> <p>Once authentication is established, we demonstrate how to configure authorization policies for routes based on JWT claims from the user's access token.</p> <p>This example uses Okta as the identity provider where we define our users and their level of access to the application.</p>"},{"location":"oidc/#okta-configuration","title":"Okta configuration","text":"<p>You will configure two users, one will be a default user with standard access to the application, the other will be a privileged user with access to additional endpoints in the application.</p>"},{"location":"oidc/#configure-groups","title":"Configure Groups","text":"<p>Create a group named admin.</p> <p>In Okta:</p> <ul> <li>Navigate to Directory and then to Groups.</li> <li>Click the button Add group.</li> <li>Enter the group name.</li> </ul>"},{"location":"oidc/#configure-users","title":"Configure Users","text":"<p>Create a user with username johndoe@example.com and another with username zeboss@example.com.</p> <p>In Okta:</p> <ul> <li>Navigate to Directory and then to People.</li> <li>Click the button Add person.</li> <li>Enter the details:  user type (User), first and last names, the username (above email address).</li> <li>Check I will set the password.</li> <li>Enter a password.</li> <li>Uncheck User must change password on first login.</li> <li>For the zeboss user, also associate them to the group admin via the Groups field.</li> <li>Click Save.</li> </ul>"},{"location":"oidc/#configure-the-application","title":"Configure the Application","text":"<p>The following instructions are for the hostname <code>httpbin.esuez.org</code>.</p> <p>Edit this value for your specific domain.</p> <p>In Okta:</p> <ul> <li>Navigate to Applications and then to Application.</li> <li>Click the button Create App Integration.</li> <li>Select OIDC as the sign-in method, and Web Application for the application type, and click Next.</li> <li>For App integration name, enter <code>httpbin.esuez.org</code>.</li> <li>Specify <code>https://httpbin.esuez.org/oauth2/callback</code> for the Sign-in redirect URIs field.</li> <li>Enter <code>https://httpbin.esuez.org/logout</code> for the Sign-out redirect URIs field.</li> <li>Click Save.</li> </ul> <p>Edit the application as follows:</p> <ul> <li>Select the tab named Assignments.</li> <li>Click the Assign button.</li> <li>Select Assign to People and assign both users to the application.</li> <li>Select Assign to Groups and assign the admin group to the application.</li> </ul> <p>In the General tab, make note of the client id and client secret. You will need both to configure the environment variables CLIENT_ID and CLIENT_SECRET.</p>"},{"location":"oidc/#configure-the-authorization-server","title":"Configure the Authorization Server","text":"<p>In Okta:</p> <ul> <li>Navigate to Security and then to API.</li> <li>Under Authorization Servers select the existing default authorization server.</li> <li>Make note of the issuer URL to set the ISSUER environment variable.</li> <li>Select the Claims tab.</li> <li>Click the button Add Claim.</li> <li>Set the claim name to access.</li> <li>Keep the defaults: include in token type \"Access Token\", and value type of \"Expression\".</li> <li>For the expression value, enter:  <code>(user == null) ? \"default\" : user.isMemberOfGroupName(\"admin\") ? \"privileged\" : \"default\"</code></li> <li>Click Create.</li> </ul> <p>The above expression translates admin group membership to the value \"privileged\"; absence of membership results in the value \"default.\"</p>"},{"location":"oidc/#test-the-token","title":"Test the token","text":"<ul> <li>Select the tab Token Preview</li> <li>Select the httpbin app integration, the grant type of authorization code, one of the two users, the the scope named openid</li> <li>Select Preview Token</li> <li>Select the tab named token (that would be the access token)</li> <li>Verify that the payload has a claim named access with value of privileged for the admin user and default for the other user.</li> </ul>"},{"location":"oidc/#configuring-authentication","title":"Configuring Authentication","text":"<p>Before proceeding, configure your issuer URL, client id, and client secret.</p> <p>For example:</p> <pre><code>export ISSUER=\"https://dev-*****.okta.com/oauth2/default\"\nexport CLIENT_ID=\"...\"\nexport CLIENT_SECRET=\"*****\"\n</code></pre>"},{"location":"oidc/#kubernetes-secret","title":"Kubernetes secret","text":"<p>Create a Kubernetes secret for the client secret:</p> <pre><code>kubectl create secret generic httpbin-client-secret \\\n  --from-literal=client-secret=$CLIENT_SECRET\n</code></pre>"},{"location":"oidc/#security-policy","title":"Security policy","text":"<p>Review the following security policy specification:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: SecurityPolicy\nmetadata:\n  name: httpbin-security-policy\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  oidc:\n    provider:\n      issuer: \"$ISSUER\"\n    clientID: \"$CLIENT_ID\"\n    clientSecret:\n      name: httpbin-client-secret\n    redirectURL: \"https://httpbin.esuez.org/oauth2/callback\"\n    logoutPath: \"/logout\"\n</code></pre> <p>We are basically configuring OIDC authentication for the route for the httpbin application.</p> <p>Apply the policy, with variable substitution:</p> <pre><code>envsubst &lt; oidc/oidc-policy.yaml | kubectl apply -f -\n</code></pre>"},{"location":"oidc/#test-it","title":"Test it","text":"<ol> <li>Visit the httpbin route.     You will be redirected to your identity provider.</li> <li>Sign in.     You will be redirected back to the target application.</li> </ol>"},{"location":"oidc/#authorization","title":"Authorization","text":"<p>Review the following augmented security policy specification:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: SecurityPolicy\nmetadata:\n  name: httpbin-security-policy\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  oidc:\n    provider:\n      issuer: \"$ISSUER\"\n    clientID: \"$CLIENT_ID\"\n    clientSecret:\n      name: httpbin-client-secret\n    redirectURL: \"https://httpbin.esuez.org/oauth2/callback\"\n    logoutPath: \"/logout\"\n  jwt:\n    providers:\n    - name: okta\n      issuer: \"$ISSUER\"\n      recomputeRoute: true\n      claimToHeaders:\n      - claim: sub\n        header: x-sub\n      - claim: access\n        header: x-access\n      remoteJWKS:\n        uri: \"$ISSUER/v1/keys\"\n</code></pre> <p>We are adding a JWT provider that will populate the header <code>x-access</code> with the value from the <code>access</code> claim (default or privileged).</p> <p>Apply the policy, with variable substitution:</p> <pre><code>envsubst &lt; oidc/security-policy.yaml | kubectl apply -f -\n</code></pre> <p>Next, expose the \"admin\" routes only to privileged users:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin\nspec:\n  hostnames:\n  - httpbin.esuez.org\n  parentRefs:\n  - name: eg\n    sectionName: https\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: /headers\n    - path:\n        type: Exact\n        value: /oauth2/callback\n    - path:\n        type: Exact\n        value: /logout\n    backendRefs:\n    - name: httpbin\n      port: 8000\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /\n      headers:\n      - name: x-access\n        value: \"privileged\"\n    backendRefs:\n    - name: httpbin\n      port: 8000\n  - backendRefs:\n    - name: invalid-backend\n      port: 8080\n</code></pre> <p>Above:</p> <ul> <li>We give access to the exact endpoint (path) <code>/headers</code> to all authenticated users.</li> <li>For any other path (path prefix of /), we match only if the header <code>x-access</code> is <code>privileged</code>.</li> </ul> <p>Other than the <code>/headers</code> (and oauth) endpoints, non-privileged users will not have routes to any of the other endpoints of the <code>httpbin</code> application.</p> <p>Apply the claim-based routing policy:</p> <pre><code>kubectl apply -f oidc/authz-route.yaml\n</code></pre> <p>To test the policy:</p> <ul> <li>Sign in as a non-privileged user and verify that you can access the <code>/headers</code> endpoint but no other <code>httpbin</code> application endpoints.</li> <li>Sign in as a privileged user and verify that this user has access to all of the <code>httpbin</code> app endpoints.</li> </ul>"},{"location":"oidc/#references","title":"References","text":"<ul> <li>Envoy Gateway OIDC Authentication Task</li> <li>JWT claims-based routing</li> </ul>"},{"location":"ratelimit/","title":"Rate limiting","text":"<p>Warning</p> <p>If during setup you chose to install Envoy Gateway, then before you proceed with this lab, you will need to deploy Redis, and reconfigure Envoy Gateway with rate limiting pointing to the URL of the Redis instance you deployed.</p> <p>Detailed instructions are available here.</p> <p>Similar to retries, rate limiting is not part of the Kubernetes Gateway API specification, and is configured through Envoy Gateway's BackendTrafficPolicy resource.</p> <p>The rate limit is associated with the HTTPRoute you wish to limit.</p>"},{"location":"ratelimit/#simple-example","title":"Simple example","text":"<p>Configure access to <code>httpbin</code> to be limited to three requests per minute:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: BackendTrafficPolicy \nmetadata:\n  name: httpbin-trafficpolicy\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  rateLimit:\n    type: Global\n    global:\n      rules:\n      - limit:\n          requests: 3\n          unit: Minute\n</code></pre> <pre><code>kubectl apply -f ratelimit/simple.yaml\n</code></pre>"},{"location":"ratelimit/#test-it","title":"Test it","text":"<p>Send four requests in succession, the fourth should be rate-limited:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>for i in {1..4}; do\n  curl --insecure --head https://httpbin.esuez.org/\ndone\n</code></pre> <pre><code>for i in {1..4}; do\n  curl --insecure --head https://httpbin.esuez.org/ --resolve httpbin.esuez.org:443:$GATEWAY_IP\ndone\n</code></pre> <p>Here is the captured output:</p> <pre><code>HTTP/2 200\nserver: gunicorn/19.9.0\ndate: Tue, 07 May 2024 22:33:12 GMT\ncontent-type: text/html; charset=utf-8\ncontent-length: 9593\naccess-control-allow-origin: *\naccess-control-allow-credentials: true\nx-ratelimit-limit: 3, 3;w=60\nx-ratelimit-remaining: 2\nx-ratelimit-reset: 48\n\nHTTP/2 200\nserver: gunicorn/19.9.0\ndate: Tue, 07 May 2024 22:33:12 GMT\ncontent-type: text/html; charset=utf-8\ncontent-length: 9593\naccess-control-allow-origin: *\naccess-control-allow-credentials: true\nx-ratelimit-limit: 3, 3;w=60\nx-ratelimit-remaining: 1\nx-ratelimit-reset: 48\n\nHTTP/2 200\nserver: gunicorn/19.9.0\ndate: Tue, 07 May 2024 22:33:12 GMT\ncontent-type: text/html; charset=utf-8\ncontent-length: 9593\naccess-control-allow-origin: *\naccess-control-allow-credentials: true\nx-ratelimit-limit: 3, 3;w=60\nx-ratelimit-remaining: 0\nx-ratelimit-reset: 48\n\nHTTP/2 429\nx-envoy-ratelimited: true\nx-ratelimit-limit: 3, 3;w=60\nx-ratelimit-remaining: 0\nx-ratelimit-reset: 48\ndate: Tue, 07 May 2024 22:33:12 GMT\n</code></pre> <p>Above, note the <code>x-ratelimit-*</code> headers that inform us of the limit, the number of requests remaining, and the amount of time (in seconds) until the corresponding counter is reset.</p>"},{"location":"ratelimit/#verify-tail-the-gateway-logs","title":"Verify: Tail the gateway logs","text":"<pre><code>kubectl logs --tail 1 -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default | jq\n</code></pre> <p>Below is a copy of the prettified JSON log line:</p> <pre><code>{\n  \"start_time\": \"2024-05-09T00:44:06.909Z\",\n  \"method\": \"HEAD\",\n  \"x-envoy-origin-path\": \"/\",\n  \"protocol\": \"HTTP/2\",\n  \"response_code\": \"429\",\n  \"response_flags\": \"RL\",\n  \"response_code_details\": \"request_rate_limited\",\n  \"connection_termination_details\": \"-\",\n  \"upstream_transport_failure_reason\": \"-\",\n  \"bytes_received\": \"0\",\n  \"bytes_sent\": \"0\",\n  \"duration\": \"3\",\n  \"x-envoy-upstream-service-time\": \"-\",\n  \"x-forwarded-for\": \"172.19.0.4\",\n  \"user-agent\": \"curl/8.7.1\",\n  \"x-request-id\": \"a5216e48-3243-42d7-b3f4-8af119efd232\",\n  \":authority\": \"httpbin.esuez.org\",\n  \"upstream_host\": \"-\",\n  \"upstream_cluster\": \"httproute/default/httpbin/rule/0\",\n  \"upstream_local_address\": \"-\",\n  \"downstream_local_address\": \"10.42.0.21:10443\",\n  \"downstream_remote_address\": \"172.19.0.4:59056\",\n  \"requested_server_name\": \"httpbin.esuez.org\",\n  \"route_name\": \"httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\"\n}\n</code></pre> <p>Note the Envoy response flag is RL: RateLimited.</p>"},{"location":"ratelimit/#rate-limit-distinct-users","title":"Rate limit distinct users","text":"<p>It is more common for individual users to each have their own limit.</p> <p>The below example adds a rate limit selection condition to distinguish between users by http header name of <code>x-user-id</code>:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: BackendTrafficPolicy \nmetadata:\n  name: httpbin-trafficpolicy\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  rateLimit:\n    type: Global\n    global:\n      rules:\n      - clientSelectors:\n        - headers:\n          - type: Distinct\n            name: x-user-id\n        limit:\n          requests: 3\n          unit: Minute\n</code></pre> <pre><code>kubectl apply -f ratelimit/distinct-users.yaml\n</code></pre>"},{"location":"ratelimit/#test-it_1","title":"Test it","text":"<p>Sending multiple requests for the same user in succession will produce a result similar to the above simple example:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>for i in {1..4}; do\n  curl --insecure --head -H \"x-user-id: eitan\" https://httpbin.esuez.org/\ndone\n</code></pre> <pre><code>for i in {1..4}; do\n  curl --insecure --head -H \"x-user-id: eitan\" https://httpbin.esuez.org/ \\\n    --resolve httpbin.esuez.org:443:$GATEWAY_IP\ndone\n</code></pre> <p>Following that up with another set of requests from a different user demonstrates that each user has their own, separate rate limiting counter:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>for i in {1..4}; do\n  curl --insecure --head -H \"x-user-id: johndoe\" https://httpbin.esuez.org/\ndone\n</code></pre> <pre><code>for i in {1..4}; do\n  curl --insecure --head -H \"x-user-id: johndoe\" https://httpbin.esuez.org/ \\\n    --resolve httpbin.esuez.org:443:$GATEWAY_IP\ndone\n</code></pre> <p>The curious may wish to inspect the translated configuration at the Envoy proxy:</p> <pre><code>egctl config envoy-proxy route -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default \\\n  -o yaml | bat -l yaml\n</code></pre> <p>Here is a sanitized copy of the captured output:</p> <pre><code>envoy-gateway-system:\n  envoy-default-eg-e41e7b31-c7657fcf5-gsgvs:\n    dynamicRouteConfigs:\n    - ...\n    - routeConfig:\n        name: default/eg/https\n        virtualHosts:\n        - domains:\n          - httpbin.esuez.org\n          name: default/eg/https/httpbin_esuez_org\n          routes:\n          - match:\n              prefix: /\n            name: httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\n            route:\n              cluster: httproute/default/httpbin/rule/0\n              rateLimits:\n              - actions:\n                - genericKey:\n                    descriptorKey: httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\n                    descriptorValue: httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\n                - requestHeaders:\n                    descriptorKey: rule-0-match-0\n                    headerName: x-user-id\n</code></pre>"},{"location":"redirect/","title":"Redirect HTTP to HTTPS","text":""},{"location":"redirect/#configure-redirection","title":"Configure redirection","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin-redirect-to-https\nspec:\n  hostnames:\n  - httpbin.esuez.org\n  parentRefs:\n  - name: eg\n    sectionName: http\n  rules:\n  - filters:\n    - type: RequestRedirect\n      requestRedirect:\n        scheme: https\n        statusCode: 301\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin\nspec:\n  hostnames:\n  - httpbin.esuez.org\n  parentRefs:\n  - name: eg\n    sectionName: https\n  rules:\n  - backendRefs:\n    - name: httpbin\n      port: 8000\n</code></pre> <pre><code>kubectl apply -f redirect/httpbin-to-https.yaml\n</code></pre>"},{"location":"redirect/#test","title":"Test","text":"<p>Verify that you get a 301 response when curling the http endpoint:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl -v http://httpbin.esuez.org/\n</code></pre> <pre><code>curl -v http://httpbin.esuez.org/ --resolve httpbin.esuez.org:80:$GATEWAY_IP\n</code></pre> <p>Here is a copy of the captured output:</p> <pre><code>* Host httpbin.esuez.org:80 was resolved.\n* IPv6: (none)\n* IPv4: 34.121.222.176\n*   Trying 34.121.222.176:80...\n* Connected to httpbin.esuez.org (34.121.222.176) port 80\n&gt; GET / HTTP/1.1\n&gt; Host: httpbin.esuez.org\n&gt; User-Agent: curl/8.7.1\n&gt; Accept: */*\n&gt;\n* Request completely sent off\n&lt; HTTP/1.1 301 Moved Permanently\n&lt; location: https://httpbin.esuez.org:443/\n&lt; date: Tue, 07 May 2024 21:21:19 GMT\n&lt; content-length: 0\n&lt;\n* Connection #0 to host httpbin.esuez.org left intact\n</code></pre>"},{"location":"retries/","title":"Retries","text":"<p>Retries are an example of how EG extends the Kubernetes Gateway API using Policy Attachments.</p>"},{"location":"retries/#review-gateway-related-crds","title":"Review Gateway-related CRDs","text":"<pre><code>kubectl api-resources | grep gateway\n</code></pre> <p>Here is a slightly sanitized copy of the captured output:</p> <pre><code>gateway.envoyproxy.io/v1alpha1       Backend\ngateway.envoyproxy.io/v1alpha1       BackendTrafficPolicy\ngateway.envoyproxy.io/v1alpha1       ClientTrafficPolicy\ngateway.envoyproxy.io/v1alpha1       EnvoyExtensionPolicy\ngateway.envoyproxy.io/v1alpha1       EnvoyPatchPolicy\ngateway.envoyproxy.io/v1alpha1       EnvoyProxy\ngateway.envoyproxy.io/v1alpha1       SecurityPolicy\ngateway.networking.k8s.io/v1alpha2   BackendLBPolicy\ngateway.networking.k8s.io/v1alpha3   BackendTLSPolicy\ngateway.networking.k8s.io/v1         GatewayClass\ngateway.networking.k8s.io/v1         Gateway\ngateway.networking.k8s.io/v1         GRPCRoute\ngateway.networking.k8s.io/v1         HTTPRoute\ngateway.networking.k8s.io/v1beta1    ReferenceGrant\ngateway.networking.k8s.io/v1alpha2   TCPRoute\ngateway.networking.k8s.io/v1alpha2   TLSRoute\ngateway.networking.k8s.io/v1alpha2   UDPRoute\n</code></pre>"},{"location":"retries/#use-backendtrafficpolicy-to-configure-retries","title":"Use BackendTrafficPolicy to configure retries","text":"<pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: BackendTrafficPolicy\nmetadata:\n  name: httpbin-trafficpolicy\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  retry:\n    numRetries: 5\n    perRetry:\n      backOff:\n        baseInterval: 100ms\n        maxInterval: 10s\n      timeout: 250ms\n    retryOn:\n      httpStatusCodes:\n        - 500\n      triggers:\n        - connect-failure\n        - retriable-status-codes\n</code></pre> <pre><code>kubectl apply -f retries/httpbin-policy.yaml\n</code></pre>"},{"location":"retries/#review-the-proxys-stats","title":"Review the proxy's \"stats\"","text":"<p>Specifically, the <code>envoy_cluster_upstream_rq_retry</code> metric:</p> <pre><code>watch 'egctl x stats envoy-proxy -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default \\\n  | grep \"envoy_cluster_upstream_rq_retry{envoy_cluster_name=\\\"httproute/default/httpbin/rule/0\\\"}\"'\n</code></pre> <p>In another terminal, call a failing endpoint:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl --insecure --head https://httpbin.esuez.org/status/500\n</code></pre> <pre><code>curl --insecure --head https://httpbin.esuez.org/status/500 \\\n  --resolve httpbin.esuez.org:443:$GATEWAY_IP\n</code></pre> <p>Another convenient way to get at the stats exposed by the Envoy proxy is through the Envoy admin interface:</p> <pre><code>egctl x dashboard envoy-proxy -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default\n</code></pre> <p>Click on the <code>stats</code> endpoint and look for metrics with \"retry\" in their name.</p>"},{"location":"retries/#verify-tail-the-gateway-logs","title":"Verify: Tail the gateway logs","text":"<pre><code>kubectl logs --tail 1 -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default | jq\n</code></pre> <p>Below is a copy of the prettified JSON log line:</p> <pre><code>{\n    \"start_time\": \"2024-05-07T21:28:06.447Z\",\n    \"method\": \"HEAD\",\n    \"x-envoy-origin-path\": \"/status/500\",\n    \"protocol\": \"HTTP/2\",\n    \"response_code\": \"500\",\n    \"response_flags\": \"URX\",\n    \"response_code_details\": \"via_upstream\",\n    \"connection_termination_details\": \"-\",\n    \"upstream_transport_failure_reason\": \"-\",\n    \"bytes_received\": \"0\",\n    \"bytes_sent\": \"0\",\n    \"duration\": \"1837\",\n    \"x-envoy-upstream-service-time\": \"-\",\n    \"x-forwarded-for\": \"136.49.247.103\",\n    \"user-agent\": \"curl/8.7.1\",\n    \"x-request-id\": \"f8d9ee84-0f3b-4bc8-a8b7-a023226704b9\",\n    \":authority\": \"httpbin.esuez.org\",\n    \"upstream_host\": \"10.48.2.12:8080\",\n    \"upstream_cluster\": \"httproute/default/httpbin/rule/0\",\n    \"upstream_local_address\": \"10.48.0.13:36898\",\n    \"downstream_local_address\": \"10.48.0.13:10443\",\n    \"downstream_remote_address\": \"136.49.247.103:52999\",\n    \"requested_server_name\": \"httpbin.esuez.org\",\n    \"route_name\": \"httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\"\n}\n</code></pre> <p>Note the Envoy response flag is URX: UpstreamRetryLimitExceeded.</p>"},{"location":"retries/#verify-review-the-proxy-configuration","title":"Verify: Review the proxy configuration","text":"<pre><code>egctl config envoy-proxy route -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default \\\n  -o yaml | bat -l yaml\n</code></pre> <p>Confirm that the routing configuration has been updated with the retry rule.</p> <p>Here is a sanitized copy of the captured output:</p> <pre><code>envoy-gateway-system:\n  envoy-default-eg-e41e7b31-c7657fcf5-gsgvs:\n    dynamicRouteConfigs:\n    ...\n    - routeConfig:\n        name: default/eg/https\n        virtualHosts:\n        - domains:\n          - httpbin.esuez.org\n          name: default/eg/https/httpbin_esuez_org\n          routes:\n          - match:\n              prefix: /\n            name: httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\n            route:\n              cluster: httproute/default/httpbin/rule/0\n              retryPolicy:\n                hostSelectionRetryMaxAttempts: \"5\"\n                numRetries: 5\n                perTryTimeout: 0.250s\n                retriableStatusCodes:\n                - 500\n                retryBackOff:\n                  baseInterval: 0.100s\n                  maxInterval: 10s\n                retryHostPredicate:\n                - name: envoy.retry_host_predicates.previous_hosts\n                retryOn: connect-failure,retriable-status-codes\n</code></pre>"},{"location":"retries/#summary","title":"Summary","text":"<p>To configure retries, we had to resort to a BackingTrafficPolicy, an extension to the Gateway API. In contrast, compare with timeouts, which are configured directly on the HTTPRoute resource, since timeouts are a part of the Kubernetes Gateway API specification.</p>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#artifacts","title":"Artifacts","text":"<p>Download all yaml artifacts referenced in all scenarios as a single .tgz file here.</p>"},{"location":"setup/#provision-a-cluster","title":"Provision a cluster","text":"On GCPLocally with k3d <pre><code>#!/bin/sh\n\ngcloud container clusters create my-k8s-cluster \\\n  --cluster-version latest \\\n  --machine-type n1-standard-2 \\\n  --num-nodes 3 \\\n  --network default \\\n  --scopes \"https://www.googleapis.com/auth/ndev.clouddns.readwrite\"\n</code></pre> <pre><code>./setup/make-gke-cluster\n</code></pre> <pre><code>k3d cluster create my-k8s-cluster \\\n  --k3s-arg \"--disable=traefik@server:0\" \\\n  --port 80:80@loadbalancer \\\n  --port 443:443@loadbalancer\n</code></pre> <p>About k3d.</p>"},{"location":"setup/#install-eg-or-teg","title":"Install EG or TEG","text":"<p>TEG installs Redis and the Envoy rate limit service, meaning that it's pre-configured for rate-limiting.</p> Install Envoy GatewayInstall TEG <pre><code>helm install eg oci://docker.io/envoyproxy/gateway-helm \\\n  --version v1.1.0 \\\n  -n envoy-gateway-system --create-namespace\n</code></pre> <pre><code>helm install teg oci://docker.io/tetrate/teg-envoy-gateway-helm \\\n  --version v1.0.1 \\\n  -n envoy-gateway-system --create-namespace\n</code></pre> <p>Review the deployments in <code>envoy-gateway-system</code>:</p> <pre><code>kubectl get deploy -n envoy-gateway-system\n</code></pre> <p>See architecture.</p>"},{"location":"setup/#install-external-dns","title":"Install <code>external-dns</code>","text":"<p>A convenience that automatically configures DNS for routes.</p> <p>Warning</p> <p>This will not work locally, and requires edits to point to your DNS zone and provider.</p> <pre><code>kubectl apply -f setup/external-dns.yaml\n</code></pre>"},{"location":"setup/#define-a-gatewayclass","title":"Define a GatewayClass:","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: eg\nspec:\n  controllerName: gateway.envoyproxy.io/gatewayclass-controller\n</code></pre> <pre><code>kubectl apply -f setup/gateway-class.yaml\n</code></pre>"},{"location":"setup/#deploy-a-gateway","title":"Deploy a Gateway","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: eg\nspec:\n  gatewayClassName: eg\n  listeners:\n  - name: http\n    protocol: HTTP\n    port: 80\n</code></pre> <pre><code>kubectl apply -f setup/gateway-http.yaml\n</code></pre> <p>Wait for the gateway to become available:</p> <pre><code>kubectl wait gtw/eg --for=condition=Programmed\n</code></pre>"},{"location":"setup/#test-it","title":"Test it","text":"Obtain Gateway IPUsing a local k3d cluster <pre><code>export GATEWAY_IP=$(kubectl get gtw eg -o jsonpath='{.status.addresses[0].value}')\n</code></pre> <p>For <code>k3d</code>, use 127.0.0.1 as your GATEWAY_IP</p> <pre><code>export GATEWAY_IP=127.0.0.1\n</code></pre> <pre><code>curl -v http://$GATEWAY_IP/\n</code></pre> <pre><code>*   Trying 34.121.222.176:80...\n* Connected to 34.121.222.176 (34.121.222.176) port 80\n&gt; GET / HTTP/1.1\n&gt; Host: 34.121.222.176\n&gt; User-Agent: curl/8.7.1\n&gt; Accept: */*\n&gt;\n* Request completely sent off\n&lt; HTTP/1.1 404 Not Found\n&lt; date: Tue, 07 May 2024 23:39:35 GMT\n&lt; content-length: 0\n&lt;\n* Connection #0 to host 34.121.222.176 left intact\n</code></pre> <p>Why do we get a 404 (Not Found)?</p>"},{"location":"shared-gw/","title":"Shared Gateway","text":"<p>Deploy a second workload and a second route associated to the same gateway</p> <pre><code>kubectl apply -f apps/customers.yaml -f apps/web-frontend.yaml\n</code></pre>"},{"location":"shared-gw/#configure-the-route","title":"Configure the route","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: web-frontend\nspec:\n  hostnames:\n  - customers-frontend.esuez.org\n  parentRefs:\n  - name: eg\n  rules:\n  - backendRefs:\n    - name: web-frontend\n      port: 80\n</code></pre> <pre><code>kubectl apply -f shared-gw/web-frontend-route.yaml\n</code></pre>"},{"location":"shared-gw/#verify","title":"Verify","text":"<p>After the DNS entry is created, verify that the route is reachable:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl http://customers-frontend.esuez.org/\n</code></pre> <pre><code>curl http://customers-frontend.esuez.org/ --resolve customers-frontend.esuez.org:80:$GATEWAY_IP\n</code></pre>"},{"location":"shared-gw/#inspect-route-configuration","title":"Inspect route configuration","text":"<pre><code>egctl config envoy-proxy route -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default \\\n  -o yaml | bat -l yaml\n</code></pre> <p>Here is a slightly sanitized copy of the captured output:</p> <pre><code>envoy-gateway-system:\n  envoy-default-eg-e41e7b31-59b4dd766f-sf78k:\n    dynamicRouteConfigs:\n    - routeConfig:\n        name: default/eg/http\n        virtualHosts:\n        - domains:\n          - httpbin.esuez.org\n          name: default/eg/http/httpbin_esuez_org\n          routes:\n          - match:\n              prefix: /\n            name: httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\n            route:\n              cluster: httproute/default/httpbin/rule/0\n        - domains:\n          - customers-frontend.esuez.org\n          name: default/eg/http/customers-frontend_esuez_org\n          routes:\n          - match:\n              prefix: /\n            name: httproute/default/web-frontend/rule/0/match/0/customers-frontend_esuez_org\n            route:\n              cluster: httproute/default/web-frontend/rule/0\n</code></pre>"},{"location":"simple-route/","title":"Simple routing","text":""},{"location":"simple-route/#deploy-a-workload","title":"Deploy a workload","text":"<pre><code>kubectl apply -f apps/httpbin.yaml\n</code></pre>"},{"location":"simple-route/#deploy-an-httproute-to-httpbin","title":"Deploy an HTTPRoute to <code>httpbin</code>","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin\n  annotations:\n    external-dns.alpha.kubernetes.io/ttl: \"60\"\nspec:\n  hostnames:\n  - httpbin.esuez.org\n  parentRefs:\n  - name: eg\n  rules:\n  - backendRefs:\n    - name: httpbin\n      port: 8000\n</code></pre> <pre><code>kubectl apply -f simple-route/httpbin-route.yaml\n</code></pre>"},{"location":"simple-route/#verify","title":"Verify","text":"<p>After the DNS entry is created for the hostname specified in the HTTPRoute, try to access the app:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl http://httpbin.esuez.org/json\n</code></pre> <pre><code>curl http://httpbin.esuez.org/json --resolve httpbin.esuez.org:80:$GATEWAY_IP\n</code></pre>"},{"location":"takeaways/","title":"Takeaways","text":"<ul> <li> <p>Envoy Gateway has come a long way.</p> <p>When Matt Klein announced a collaboration between multiple vendors (Tetrate, Ambassador labs, VMware..) to create an open source foundation for Envoy-based gateway solutions, the project was just getting started.</p> </li> <li> <p>EG recently reached the v1.1.0 milestone and is now fully conformant implementation of the Kubernetes Gateway API.</p> </li> <li> <p>EG achieves its objective of unlocking the capabilities of envoyproxy, and making it easy to deploy and configure in a cloud-native environment.</p> </li> <li> <p>There's a lot of goodness to unpack.</p> <p>We scratched the surface exploring only a few example scenarios. The Envoy Gateway tasks section provides recipes for dozens of traffic management and security scenarios.</p> </li> <li> <p>This was only an introduction to Envoy Gateway.</p> <p>Besides the various routing and security configuration scenarios, it's important to explore other facets of EG, including operations and observability.</p> </li> </ul>"},{"location":"tls/","title":"TLS","text":"<p>The objective is to configure the Gateway to serve <code>httpbin</code> over TLS.</p>"},{"location":"tls/#deploy-cert-manager","title":"Deploy <code>cert-manager</code>","text":"<p>We decide to let cert-manager manage certificates on our behalf.</p> <pre><code>helm repo add jetstack https://charts.jetstack.io --force-update\nhelm repo update\n</code></pre> <pre><code>helm upgrade --install --create-namespace --namespace cert-manager \\\n  --set crds.enabled=true \\\n  --set \"extraArgs={--enable-gateway-api}\" \\\n  cert-manager jetstack/cert-manager\n</code></pre>"},{"location":"tls/#create-a-self-signed-issuer","title":"Create a self-signed issuer","text":"<pre><code>---\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: self-signed\nspec:\n  selfSigned: {}\n</code></pre> <pre><code>kubectl apply -f tls/selfsigned-issuer.yaml\n</code></pre>"},{"location":"tls/#add-an-https-listener","title":"Add an HTTPS listener","text":"<p>Add an HTTPS listener for <code>httpbin.esuez.org</code> hostname on the gateway, configured to terminate TLS:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: eg\n  annotations:\n    cert-manager.io/cluster-issuer: self-signed\nspec:\n  gatewayClassName: eg\n  listeners:\n  - name: http\n    protocol: HTTP\n    port: 80\n  - name: https\n    protocol: HTTPS\n    port: 443\n    hostname: httpbin.esuez.org\n    tls:\n      mode: Terminate\n      certificateRefs:\n      - name: httpbin-cert\n</code></pre> <pre><code>kubectl apply -f tls/gateway-add-https.yaml\n</code></pre>"},{"location":"tls/#test-it","title":"Test it","text":"<p>Access httpbin over TLS:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl --insecure -v --head https://httpbin.esuez.org/\n</code></pre> <pre><code>curl --insecure -v --head https://httpbin.esuez.org/ \\\n   --resolve httpbin.esuez.org:443:$GATEWAY_IP\n</code></pre>"},{"location":"traffic-split/","title":"Traffic Splitting","text":"<p>This scenario demonstrates traffic splitting:  how the <code>weight</code> field in an HttpRoute can be used to specify the distribution of traffic between two backend references, two services.</p>"},{"location":"traffic-split/#context","title":"Context","text":"<p>The <code>customers</code> service should already be deployed in the default namespace (see Shared Gateway).</p>"},{"location":"traffic-split/#instructions","title":"Instructions","text":"<ol> <li> <p>Deploy <code>customers-v2</code> backing deployment:</p> <pre><code>---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: customers-v2\n  labels:\n    app: customers\n    version: v2\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: customers\n      version: v2\n  template:\n    metadata:\n      labels:\n        app: customers\n        version: v2\n    spec:\n      serviceAccountName: customers\n      containers:\n      - image: gcr.io/tetratelabs/customers:2.0.0\n        imagePullPolicy: Always\n        name: svc\n        ports:\n        - containerPort: 3000\n</code></pre> <pre><code>kubectl apply -f traffic-split/customers-v2.yaml\n</code></pre> </li> <li> <p>Define services for each v1 and v2 subsets:</p> <pre><code>---\napiVersion: v1\nkind: Service\nmetadata:\n  name: customers-v1\nspec:\n  selector:\n    app: customers\n    version: v1\n  ports:\n  - port: 80\n    name: http\n    targetPort: 3000\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: customers-v2\nspec:\n  selector:\n    app: customers\n    version: v2\n  ports:\n  - port: 80\n    name: http\n    targetPort: 3000\n</code></pre> <pre><code>kubectl apply -f traffic-split/customers-subsets.yaml\n</code></pre> </li> <li> <p>Define an HttpRoute that splits traffic 80/20 between v1 and v2:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: customers\nspec:\n  hostnames:\n  - customers.esuez.org\n  parentRefs:\n  - name: eg\n  rules:\n  - backendRefs:\n    - name: customers-v1\n      port: 80\n      weight: 80\n    - name: customers-v2\n      port: 80\n      weight: 20\n</code></pre> <pre><code>kubectl apply -f traffic-split/customers-route.yaml\n</code></pre> </li> </ol>"},{"location":"traffic-split/#test-it","title":"Test it","text":"<p>Send a number of test request to the <code>customers</code> route:</p> <pre><code>for i in {1..10}; do\n  curl http://customers.esuez.org/ --resolve customers.esuez.org:80:$GATEWAY_IP\ndone\n</code></pre> <p>About 80% of requests should go to v1.</p> <p>Responses from the <code>v2</code> service can be distinguished from <code>v1</code> by their payload:  v2 returns customer names and cities, whereas v1 returns only customer names.</p>"},{"location":"wasm/","title":"WebAssembly","text":"<p>In this scenario we demonstrate how to apply a wasm extension to an HttpRoute.</p> <p>You will apply an extension policy that references a simple, pre-built wasm plugin to the HttpRoute for the <code>httpbin</code> sample application.</p> <p>The basic logic of the plugin is to inject arbitrary, configurable headers into HTTP responses on the associated route.</p>"},{"location":"wasm/#context","title":"Context","text":"<p><code>httpbin</code> is already deployed to the <code>default</code> namespace and the simple HttpRoute is already defined for it.</p>"},{"location":"wasm/#instructions","title":"Instructions","text":"<ol> <li> <p>Send a test request to the <code>httpbin</code> route:</p> <pre><code> curl -v http://httpbin.esuez.org/json --resolve httpbin.esuez.org:80:$GATEWAY_IP\n</code></pre> <p>The request should succeed, and return some json.</p> <p>Note the headers in the HTTP response.</p> </li> <li> <p>Review the following extension policy:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: EnvoyExtensionPolicy\nmetadata:\n  name: wasm-plugin\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  wasm:\n  - code:\n      type: Image\n      image:\n        url: us-central1-docker.pkg.dev/eitan-tetrate/misc-repo/wasm:v1\n    config:\n      header_1: my first header\n      header_2: \"yet another header..\"\n</code></pre> <p>Apply the policy:</p> <pre><code>kubectl apply -f wasm/extension-policy.yaml\n</code></pre> </li> <li> <p>Repeat the request:</p> <pre><code>curl -v http://httpbin.esuez.org/json --resolve httpbin.esuez.org:80:$GATEWAY_IP\n</code></pre> <p>Note the response headers contain extra headers from the configuration of the wasm plugin.</p> </li> </ol>"}]}