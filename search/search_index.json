{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Here you will find a number of scenarios that can assist you in exploring the Envoy Gateway project.</p> <p>These scenarios are an adaptation of a selection of the tasks documented on the Envoy Project's web site.</p> <p>After working through these scenarios, explore further by visiting the Envoy Gateway documentation proper.</p> <p>Sincerely,</p> <p>-- Eitan Suez &amp; the team @ Tetrate</p>"},{"location":"auth/","title":"Authentication","text":"<p>Envoy Gateway supports a number of distinct authentication mechanisms, including JWT, OIDC, external authorization, and basic auth.</p> <p>In this exercise, we keep things simple and demonstrate basic auth.</p> <p>Once more, we are dealing with a feature that is outside the current Gateway API specification, and so we use a SecurityPolicy attachment against the route we wish to protect, which in this case is the <code>httpbin</code> route.</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: SecurityPolicy\nmetadata:\n  name: httpbin-basicauth\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  basicAuth:\n    users:\n      name: httpbin-users\n</code></pre> <p>The value of the <code>name</code> field on line 13 refers a secret containing an <code>htpasswd</code> file.</p> <ol> <li> <p>Create the htpasswd file:</p> <pre><code>htpasswd -cs .htpasswd eitan\n</code></pre> </li> <li> <p>Create the secret from the generated file:</p> <pre><code>kubectl create secret generic httpbin-users --from-file=.htpasswd\n</code></pre> </li> <li> <p>Apply the security policy:</p> <pre><code>kubectl apply -f auth/basic.yaml\n</code></pre> </li> </ol>"},{"location":"auth/#test-it","title":"Test it","text":"<p>Access the application, or:</p> <ol> <li> <p>Request without credentials return a 401 (Forbidden)</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl --insecure --head https://httpbin.esuez.org/\n</code></pre> <pre><code>curl --insecure --head https://httpbin.esuez.org/ \\\n  --resolve httpbin.esuez.org:443:$GATEWAY_IP\n</code></pre> <pre><code>HTTP/2 401\ncontent-length: 58\ncontent-type: text/plain\ndate: Tue, 07 May 2024 23:18:11 GMT\n</code></pre> </li> <li> <p>Authenticated requests succeed:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl --insecure --head --user eitan:correctpassword https://httpbin.esuez.org/\n</code></pre> <pre><code>curl --insecure --head --user eitan:correctpassword https://httpbin.esuez.org/ \\\n  --resolve httpbin.esuez.org:443:$GATEWAY_IP\n</code></pre> <pre><code>HTTP/2 200\nserver: gunicorn/19.9.0\ndate: Tue, 07 May 2024 23:18:20 GMT\ncontent-type: text/html; charset=utf-8\ncontent-length: 9593\naccess-control-allow-origin: *\naccess-control-allow-credentials: true\n</code></pre> </li> <li> <p>Bad credentials produce a 401 (Forbidden):</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl --insecure --head --user eitan:wrongpassword https://httpbin.esuez.org/\n</code></pre> <pre><code>curl --insecure --head --user eitan:wrongpassword https://httpbin.esuez.org/ \\\n  --resolve httpbin.esuez.org:443:$GATEWAY_IP\n</code></pre> <pre><code>HTTP/2 401\ncontent-length: 66\ncontent-type: text/plain\ndate: Tue, 07 May 2024 23:18:23 GMT\n</code></pre> </li> </ol>"},{"location":"auth/#inspect-the-proxy-configuration","title":"Inspect the Proxy configuration","text":"<p>We can look at the Envoy listeners configuration and inspect the HTTP connection manager's filter chain to confirm that the basic auth filter is installed.</p> <pre><code>egctl config envoy-proxy listener -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default \\\n  -o yaml | bat -l yaml\n</code></pre> <p>Here is sanitized output for the HTTPS listener:</p> <pre><code>...\nfilterChains:\n- filterChainMatch:\n    serverNames:\n    - httpbin.esuez.org\n  filters:\n  - name: envoy.filters.network.http_connection_manager\n    typedConfig:\n      httpFilters:\n      - name: envoy.filters.http.basic_auth_httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\n        disabled: true\n        typedConfig:\n          '@type': type.googleapis.com/envoy.extensions.filters.http.basic_auth.v3.BasicAuth\n          users:\n            inlineBytes: W3JlZGFjdGVkXQ==\n      - name: envoy.filters.http.ratelimit\n        typedConfig:\n          '@type': type.googleapis.com/envoy.extensions.filters.http.ratelimit.v3.RateLimit\n          domain: default/eg/https\n          enableXRatelimitHeaders: DRAFT_VERSION_03\n          rateLimitService:\n            grpcService:\n              envoyGrpc:\n                clusterName: ratelimit_cluster\n            transportApiVersion: V3\n      - name: envoy.filters.http.router\n        typedConfig:\n          '@type': type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\n          suppressEnvoyHeaders: true\n  ...\n</code></pre> <p>The basic auth filter is configured at the level of the listener, but disabled there. Since the authentication rule is applied at the route level, we need to look at the route.</p> <pre><code>egctl config envoy-proxy route -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default \\\n  -o yaml | bat -l yaml\n</code></pre> <p>Here is the salient part of the output:</p> <pre><code>envoy-gateway-system:\n  envoy-default-eg-e41e7b31-c7657fcf5-tmsdt:\n    dynamicRouteConfigs:\n    ...\n    - routeConfig:\n        name: default/eg/https\n        virtualHosts:\n        - domains:\n          - httpbin.esuez.org\n          name: default/eg/https/httpbin_esuez_org\n          routes:\n          - match:\n              prefix: /\n            name: httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\n            route:\n              cluster: httproute/default/httpbin/rule/0\n              rateLimits:\n              ...\n            typedPerFilterConfig:\n              envoy.filters.http.basic_auth_httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org:\n                '@type': type.googleapis.com/envoy.config.route.v3.FilterConfig\n                config: {}\n</code></pre>"},{"location":"ext-authz/","title":"External Authorization","text":"<p>This scenario demonstrates how Envoy's external authorization filter can be applied to an HttpRoute.</p>"},{"location":"ext-authz/#context","title":"Context","text":"<p>We will use the Ext Authz service sample from the Istio distribution.</p> <p>Deploy the service:</p> <pre><code>kubectl apply -f ext-authz/ext-authz.yaml\n</code></pre>"},{"location":"ext-authz/#the-contract","title":"The contract","text":"<p>The service you just deployed will allow (200) any request bearing the header <code>x-ext-authz: allow</code>.</p> <p>The absence of the header, or the header with a value other than <code>allow</code> will be denied (403).</p>"},{"location":"ext-authz/#instructions","title":"Instructions","text":"<p>Make sure that the <code>httpbin</code> service is deployed, and a simple route is defined from the gateway to the service.</p> <p>Review the following security policy:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: SecurityPolicy\nmetadata:\n  name: ext-authz-policy\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  extAuth:\n    http:\n      backendRefs:\n      - group: \"\"\n        kind: Service\n        name: ext-authz\n        port: 8000\n    headersToExtAuth:\n    - x-ext-authz\n</code></pre> <p>Apply the policy:</p> <pre><code>kubectl apply -f security-policy.yaml\n</code></pre> <p>Send a test request:</p> <p><code>shell  curl -v -H \"x-ext-authz: allow\" http://httpbin.esuez.org/json --resolve httpbin.esuez.org:80:$GATEWAY_IP</code></p> <p>The above request should succeed.</p> <p>Absence of the header, or header value that is not \"allow\" will return a 403.</p>"},{"location":"observability/","title":"Observability","text":"<p>The following content is distilled from the Envoy Gateway docs.</p> <p>The objective is to collect Gateway metrics with Prometheus and expose them through Grafana dashboards.</p>"},{"location":"observability/#generate-a-load","title":"Generate a load","text":"<pre><code>while true; do\n  curl --head https://httpbin.esuez.org/json --resolve httpbin.esuez.org:443:$GATEWAY_IP\n  sleep 0.5\ndone\n</code></pre>"},{"location":"observability/#deploy-prometheus","title":"Deploy Prometheus","text":"<pre><code>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts\nhelm repo update\n</code></pre> <p>Then:</p> <pre><code>helm upgrade --install prometheus prometheus-community/prometheus -n monitoring --create-namespace\n</code></pre> <p>Expose the prometheus dashboard:</p> <pre><code>kubectl -n monitoring port-forward deploy/prometheus-server 9090\n</code></pre>"},{"location":"observability/#query-metrics","title":"Query metrics","text":"<p>Visit localhost:9090 and look for the retry metric from the retries lab:</p> <pre><code>envoy_cluster_upstream_rq_retry{envoy_cluster_name=\"httproute/default/httpbin/rule/0\"}\n</code></pre>"},{"location":"observability/#install-grafana","title":"Install Grafana","text":"<pre><code>helm repo add grafana https://grafana.github.io/helm-charts\nhelm repo update\n</code></pre> <p>Then:</p> <pre><code>helm upgrade --install grafana grafana/grafana -f https://raw.githubusercontent.com/envoyproxy/gateway/latest/examples/grafana/helm-values.yaml -n monitoring --create-namespace\n</code></pre> <p>Expose the Grafana dashboard:</p> <pre><code>kubectl -n monitoring port-forward deploy/grafana 3000\n</code></pre>"},{"location":"observability/#configure-grafana","title":"Configure Grafana","text":"<p>Visit localhost:3000 and login to grafana using <code>admin:admin</code>.</p> <p>Configure the prometheus data source, using the service URL:</p> <pre><code>http://prometheus-server.monitoring.svc.cluster.local/\n</code></pre>"},{"location":"observability/#import-dashboards","title":"Import dashboards","text":"<ul> <li> <p>Envoy Global</p> </li> <li> <p>Envoy Clusters</p> </li> <li> <p>Envoy Pod Resources</p> </li> </ul>"},{"location":"observability/#visit-the-dashboards","title":"Visit the dashboards","text":"<p>Monitor your gateways in style.</p>"},{"location":"ratelimit/","title":"Rate limiting","text":"<p>Warning</p> <p>If during setup you chose to install Envoy Gateway, then before you proceed with this lab, you will need to deploy Redis, and reconfigure Envoy Gateway with rate limiting pointing to the URL of the Redis instance you deployed.</p> <p>Detailed instructions are available here.</p> <p>Similar to retries, rate limiting is not part of the Kubernetes Gateway API specification, and is configured through Envoy Gateway's BackendTrafficPolicy resource.</p> <p>The rate limit is associated with the HTTPRoute you wish to limit.</p>"},{"location":"ratelimit/#simple-example","title":"Simple example","text":"<p>Configure access to <code>httpbin</code> to be limited to three requests per minute:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: BackendTrafficPolicy \nmetadata:\n  name: httpbin-trafficpolicy\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n    namespace: default\n  rateLimit:\n    type: Global\n    global:\n      rules:\n      - limit:\n          requests: 3\n          unit: Minute\n</code></pre> <pre><code>kubectl apply -f ratelimit/simple.yaml\n</code></pre>"},{"location":"ratelimit/#test-it","title":"Test it","text":"<p>Send four requests in succession, the fourth should be rate-limited:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>for i in {1..4}; do\n  curl --insecure --head https://httpbin.esuez.org/\ndone\n</code></pre> <pre><code>for i in {1..4}; do\n  curl --insecure --head https://httpbin.esuez.org/ --resolve httpbin.esuez.org:443:$GATEWAY_IP\ndone\n</code></pre> <p>Here is the captured output:</p> <pre><code>HTTP/2 200\nserver: gunicorn/19.9.0\ndate: Tue, 07 May 2024 22:33:12 GMT\ncontent-type: text/html; charset=utf-8\ncontent-length: 9593\naccess-control-allow-origin: *\naccess-control-allow-credentials: true\nx-ratelimit-limit: 3, 3;w=60\nx-ratelimit-remaining: 2\nx-ratelimit-reset: 48\n\nHTTP/2 200\nserver: gunicorn/19.9.0\ndate: Tue, 07 May 2024 22:33:12 GMT\ncontent-type: text/html; charset=utf-8\ncontent-length: 9593\naccess-control-allow-origin: *\naccess-control-allow-credentials: true\nx-ratelimit-limit: 3, 3;w=60\nx-ratelimit-remaining: 1\nx-ratelimit-reset: 48\n\nHTTP/2 200\nserver: gunicorn/19.9.0\ndate: Tue, 07 May 2024 22:33:12 GMT\ncontent-type: text/html; charset=utf-8\ncontent-length: 9593\naccess-control-allow-origin: *\naccess-control-allow-credentials: true\nx-ratelimit-limit: 3, 3;w=60\nx-ratelimit-remaining: 0\nx-ratelimit-reset: 48\n\nHTTP/2 429\nx-envoy-ratelimited: true\nx-ratelimit-limit: 3, 3;w=60\nx-ratelimit-remaining: 0\nx-ratelimit-reset: 48\ndate: Tue, 07 May 2024 22:33:12 GMT\n</code></pre> <p>Above, note the <code>x-ratelimit-*</code> headers that inform us of the limit, the number of requests remaining, and the amount of time (in seconds) until the corresponding counter is reset.</p>"},{"location":"ratelimit/#verify-tail-the-gateway-logs","title":"Verify: Tail the gateway logs","text":"<pre><code>kubectl logs --tail 1 -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default | jq\n</code></pre> <p>Below is a copy of the prettified JSON log line:</p> <pre><code>{\n  \"start_time\": \"2024-05-09T00:44:06.909Z\",\n  \"method\": \"HEAD\",\n  \"x-envoy-origin-path\": \"/\",\n  \"protocol\": \"HTTP/2\",\n  \"response_code\": \"429\",\n  \"response_flags\": \"RL\",\n  \"response_code_details\": \"request_rate_limited\",\n  \"connection_termination_details\": \"-\",\n  \"upstream_transport_failure_reason\": \"-\",\n  \"bytes_received\": \"0\",\n  \"bytes_sent\": \"0\",\n  \"duration\": \"3\",\n  \"x-envoy-upstream-service-time\": \"-\",\n  \"x-forwarded-for\": \"172.19.0.4\",\n  \"user-agent\": \"curl/8.7.1\",\n  \"x-request-id\": \"a5216e48-3243-42d7-b3f4-8af119efd232\",\n  \":authority\": \"httpbin.esuez.org\",\n  \"upstream_host\": \"-\",\n  \"upstream_cluster\": \"httproute/default/httpbin/rule/0\",\n  \"upstream_local_address\": \"-\",\n  \"downstream_local_address\": \"10.42.0.21:10443\",\n  \"downstream_remote_address\": \"172.19.0.4:59056\",\n  \"requested_server_name\": \"httpbin.esuez.org\",\n  \"route_name\": \"httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\"\n}\n</code></pre> <p>Note the Envoy response flag is RL: RateLimited.</p>"},{"location":"ratelimit/#rate-limit-distinct-users","title":"Rate limit distinct users","text":"<p>It is more common for individual users to each have their own limit.</p> <p>The below example adds a rate limit selection condition to distinguish between users by http header name of <code>x-user-id</code>:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: BackendTrafficPolicy \nmetadata:\n  name: httpbin-trafficpolicy\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n    namespace: default\n  rateLimit:\n    type: Global\n    global:\n      rules:\n      - clientSelectors:\n        - headers:\n          - type: Distinct\n            name: x-user-id\n        limit:\n          requests: 3\n          unit: Minute\n</code></pre> <pre><code>kubectl apply -f ratelimit/distinct-users.yaml\n</code></pre>"},{"location":"ratelimit/#test-it_1","title":"Test it","text":"<p>Sending multiple requests for the same user in succession will produce a result similar to the above simple example:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>for i in {1..4}; do\n  curl --insecure --head -H \"x-user-id: eitan\" https://httpbin.esuez.org/\ndone\n</code></pre> <pre><code>for i in {1..4}; do\n  curl --insecure --head -H \"x-user-id: eitan\" https://httpbin.esuez.org/ \\\n    --resolve httpbin.esuez.org:443:$GATEWAY_IP\ndone\n</code></pre> <p>Following that up with another set of requests from a different user demonstrates that each user has their own, separate rate limiting counter:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>for i in {1..4}; do\n  curl --insecure --head -H \"x-user-id: johndoe\" https://httpbin.esuez.org/\ndone\n</code></pre> <pre><code>for i in {1..4}; do\n  curl --insecure --head -H \"x-user-id: johndoe\" https://httpbin.esuez.org/ \\\n    --resolve httpbin.esuez.org:443:$GATEWAY_IP\ndone\n</code></pre> <p>The curious may wish to inspect the translated configuration at the Envoy proxy:</p> <pre><code>egctl config envoy-proxy route -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default \\\n  -o yaml | bat -l yaml\n</code></pre> <p>Here is a sanitized copy of the captured output:</p> <pre><code>envoy-gateway-system:\n  envoy-default-eg-e41e7b31-c7657fcf5-gsgvs:\n    dynamicRouteConfigs:\n    - ...\n    - routeConfig:\n        name: default/eg/https\n        virtualHosts:\n        - domains:\n          - httpbin.esuez.org\n          name: default/eg/https/httpbin_esuez_org\n          routes:\n          - match:\n              prefix: /\n            name: httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\n            route:\n              cluster: httproute/default/httpbin/rule/0\n              rateLimits:\n              - actions:\n                - genericKey:\n                    descriptorKey: httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\n                    descriptorValue: httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\n                - requestHeaders:\n                    descriptorKey: rule-0-match-0\n                    headerName: x-user-id\n</code></pre>"},{"location":"redirect/","title":"Redirect HTTP to HTTPS","text":""},{"location":"redirect/#configure-redirection","title":"Configure redirection","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin-redirect-to-https\nspec:\n  hostnames:\n  - httpbin.esuez.org\n  parentRefs:\n  - name: eg\n    sectionName: http\n  rules:\n  - filters:\n    - type: RequestRedirect\n      requestRedirect:\n        scheme: https\n        statusCode: 301\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin\nspec:\n  hostnames:\n  - httpbin.esuez.org\n  parentRefs:\n  - name: eg\n    sectionName: https\n  rules:\n  - backendRefs:\n    - name: httpbin\n      port: 8000\n</code></pre> <pre><code>kubectl apply -f redirect/httpbin-to-https.yaml\n</code></pre>"},{"location":"redirect/#test","title":"Test","text":"<p>Verify that you get a 301 response when curling the http endpoint:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl -v http://httpbin.esuez.org/\n</code></pre> <pre><code>curl -v http://httpbin.esuez.org/ --resolve httpbin.esuez.org:80:$GATEWAY_IP\n</code></pre> <p>Here is a copy of the captured output:</p> <pre><code>* Host httpbin.esuez.org:80 was resolved.\n* IPv6: (none)\n* IPv4: 34.121.222.176\n*   Trying 34.121.222.176:80...\n* Connected to httpbin.esuez.org (34.121.222.176) port 80\n&gt; GET / HTTP/1.1\n&gt; Host: httpbin.esuez.org\n&gt; User-Agent: curl/8.7.1\n&gt; Accept: */*\n&gt;\n* Request completely sent off\n&lt; HTTP/1.1 301 Moved Permanently\n&lt; location: https://httpbin.esuez.org:443/\n&lt; date: Tue, 07 May 2024 21:21:19 GMT\n&lt; content-length: 0\n&lt;\n* Connection #0 to host httpbin.esuez.org left intact\n</code></pre>"},{"location":"retries/","title":"Retries","text":"<p>Retries are an example of how EG extends the Kubernetes Gateway API using Policy Attachments.</p>"},{"location":"retries/#review-gateway-related-crds","title":"Review Gateway-related CRDs","text":"<pre><code>kubectl api-resources | grep gateway\n</code></pre> <p>Here is a slightly sanitized copy of the captured output:</p> <pre><code>gateway.envoyproxy.io/v1alpha1       BackendTrafficPolicy\ngateway.envoyproxy.io/v1alpha1       ClientTrafficPolicy\ngateway.envoyproxy.io/v1alpha1       EnvoyPatchPolicy\ngateway.envoyproxy.io/v1alpha1       EnvoyProxy\ngateway.envoyproxy.io/v1alpha1       SecurityPolicy\ngateway.networking.k8s.io/v1alpha2   BackendTLSPolicy\ngateway.networking.k8s.io/v1         GatewayClass\ngateway.networking.k8s.io/v1         Gateway\ngateway.networking.k8s.io/v1alpha2   GRPCRoute\ngateway.networking.k8s.io/v1         HTTPRoute\ngateway.networking.k8s.io/v1beta1    ReferenceGrant\ngateway.networking.k8s.io/v1alpha2   TCPRoute\ngateway.networking.k8s.io/v1alpha2   TLSRoute\ngateway.networking.k8s.io/v1alpha2   UDPRoute\n</code></pre>"},{"location":"retries/#use-backendtrafficpolicy-to-configure-retries","title":"Use BackendTrafficPolicy to configure retries","text":"<pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: BackendTrafficPolicy\nmetadata:\n  name: httpbin-trafficpolicy\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n    namespace: default\n  retry:\n    numRetries: 5\n    perRetry:\n      backOff:\n        baseInterval: 100ms\n        maxInterval: 10s\n      timeout: 250ms\n    retryOn:\n      httpStatusCodes:\n        - 500\n      triggers:\n        - connect-failure\n        - retriable-status-codes\n</code></pre> <pre><code>kubectl apply -f retries/httpbin-policy.yaml\n</code></pre>"},{"location":"retries/#review-the-proxys-stats","title":"Review the proxy's \"stats\"","text":"<p>Specifically, the <code>envoy_cluster_upstream_rq_retry</code> metric:</p> <pre><code>watch 'egctl x stats envoy-proxy -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default \\\n  | grep \"envoy_cluster_upstream_rq_retry{envoy_cluster_name=\\\"httproute/default/httpbin/rule/0\\\"}\"'\n</code></pre> <p>In another terminal, call a failing endpoint</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl --insecure --head https://httpbin.esuez.org/status/500\n</code></pre> <pre><code>curl --insecure --head https://httpbin.esuez.org/status/500 \\\n  --resolve httpbin.esuez.org:443:$GATEWAY_IP\n</code></pre> <p>Another convenient way to get at the stats exposed by the Envoy proxy is through the Envoy admin interface:</p> <pre><code>egctl x dashboard envoy-proxy -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default\n</code></pre> <p>Click on the <code>stats</code> endpoint and look for metrics with \"retry\" in their name.</p>"},{"location":"retries/#verify-tail-the-gateway-logs","title":"Verify: Tail the gateway logs","text":"<pre><code>kubectl logs --tail 1 -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default | jq\n</code></pre> <p>Below is a copy of the prettified JSON log line:</p> <pre><code>{\n    \"start_time\": \"2024-05-07T21:28:06.447Z\",\n    \"method\": \"HEAD\",\n    \"x-envoy-origin-path\": \"/status/500\",\n    \"protocol\": \"HTTP/2\",\n    \"response_code\": \"500\",\n    \"response_flags\": \"URX\",\n    \"response_code_details\": \"via_upstream\",\n    \"connection_termination_details\": \"-\",\n    \"upstream_transport_failure_reason\": \"-\",\n    \"bytes_received\": \"0\",\n    \"bytes_sent\": \"0\",\n    \"duration\": \"1837\",\n    \"x-envoy-upstream-service-time\": \"-\",\n    \"x-forwarded-for\": \"136.49.247.103\",\n    \"user-agent\": \"curl/8.7.1\",\n    \"x-request-id\": \"f8d9ee84-0f3b-4bc8-a8b7-a023226704b9\",\n    \":authority\": \"httpbin.esuez.org\",\n    \"upstream_host\": \"10.48.2.12:8080\",\n    \"upstream_cluster\": \"httproute/default/httpbin/rule/0\",\n    \"upstream_local_address\": \"10.48.0.13:36898\",\n    \"downstream_local_address\": \"10.48.0.13:10443\",\n    \"downstream_remote_address\": \"136.49.247.103:52999\",\n    \"requested_server_name\": \"httpbin.esuez.org\",\n    \"route_name\": \"httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\"\n}\n</code></pre> <p>Note the Envoy response flag is URX: UpstreamRetryLimitExceeded.</p>"},{"location":"retries/#verify-review-the-proxy-configuration","title":"Verify: Review the proxy configuration","text":"<pre><code>egctl config envoy-proxy route -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default \\\n  -o yaml | bat -l yaml\n</code></pre> <p>Confirm that the routing configuration has been updated with the retry rule.</p> <p>Here is a sanitized copy of the captured output:</p> <pre><code>envoy-gateway-system:\n  envoy-default-eg-e41e7b31-c7657fcf5-gsgvs:\n    dynamicRouteConfigs:\n    ...\n    - routeConfig:\n        name: default/eg/https\n        virtualHosts:\n        - domains:\n          - httpbin.esuez.org\n          name: default/eg/https/httpbin_esuez_org\n          routes:\n          - match:\n              prefix: /\n            name: httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\n            route:\n              cluster: httproute/default/httpbin/rule/0\n              retryPolicy:\n                hostSelectionRetryMaxAttempts: \"5\"\n                numRetries: 5\n                perTryTimeout: 0.250s\n                retriableStatusCodes:\n                - 500\n                retryBackOff:\n                  baseInterval: 0.100s\n                  maxInterval: 10s\n                retryHostPredicate:\n                - name: envoy.retry_host_predicates.previous_hosts\n                retryOn: connect-failure,retriable-status-codes\n</code></pre>"},{"location":"retries/#summary","title":"Summary","text":"<p>To configure retries, we had to resort to a BackingTrafficPolicy, an extension to the Gateway API. In contrast, compare with timeouts, which are configured directly on the HTTPRoute resource, since timeouts are a part of the Kubernetes Gateway API specification.</p>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#artifacts","title":"Artifacts","text":"<p>Download all yaml artifacts referenced in all scenarios as a single .tgz file here.</p>"},{"location":"setup/#provision-a-cluster","title":"Provision a cluster","text":"On GCPLocally with k3d <pre><code>#!/bin/sh\n\ngcloud container clusters create my-k8s-cluster \\\n  --cluster-version latest \\\n  --machine-type n1-standard-2 \\\n  --num-nodes 3 \\\n  --network default \\\n  --scopes \"https://www.googleapis.com/auth/ndev.clouddns.readwrite\"\n</code></pre> <pre><code>./setup/make-gke-cluster\n</code></pre> <pre><code>k3d cluster create my-k8s-cluster \\\n  --k3s-arg \"--disable=traefik@server:0\" \\\n  --port 80:80@loadbalancer \\\n  --port 443:443@loadbalancer\n</code></pre> <p>About k3d.</p>"},{"location":"setup/#install-eg-or-teg","title":"Install EG or TEG","text":"<p>TEG installs Redis and the Envoy rate limit service, meaning that it's pre-configured for rate-limiting.</p> Install Envoy GatewayInstall TEG <pre><code>helm install eg oci://docker.io/envoyproxy/gateway-helm \\\n  --version v0.0.0-latest \\\n  -n envoy-gateway-system --create-namespace\n</code></pre> <pre><code>helm install teg oci://docker.io/tetrate/teg-envoy-gateway-helm \\\n  --version v1.0.1 \\\n  -n envoy-gateway-system --create-namespace\n</code></pre> <p>Study the deployments in <code>envoy-gateway-system</code>:</p> <pre><code>kubectl get deploy -n envoy-gateway-system\n</code></pre> <p>See architecture.</p>"},{"location":"setup/#install-external-dns","title":"Install <code>external-dns</code>","text":"<p>A convenience that automatically configures DNS for routes.</p> <p>Warning</p> <p>This will not work locally, and requires edits to point to your DNS zone and provider.</p> <pre><code>kubectl apply -f setup/external-dns.yaml\n</code></pre>"},{"location":"setup/#define-a-gatewayclass","title":"Define a GatewayClass:","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: eg\nspec:\n  controllerName: gateway.envoyproxy.io/gatewayclass-controller\n</code></pre> <pre><code>kubectl apply -f setup/gateway-class.yaml\n</code></pre>"},{"location":"setup/#deploy-a-gateway","title":"Deploy a Gateway","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: eg\nspec:\n  gatewayClassName: eg\n  listeners:\n  - name: http\n    protocol: HTTP\n    port: 80\n</code></pre> <pre><code>kubectl apply -f setup/gateway-http.yaml\n</code></pre>"},{"location":"setup/#test-it","title":"Test it","text":"Obtain Gateway IPUsing a local k3d cluster <pre><code>export GATEWAY_IP=$(kubectl get gtw eg -o jsonpath='{.status.addresses[0].value}')\n</code></pre> <p>For <code>k3d</code>, use 127.0.0.1 as your GATEWAY_IP</p> <pre><code>export GATEWAY_IP=127.0.0.1\n</code></pre> <pre><code>curl -v http://$GATEWAY_IP/\n</code></pre> <pre><code>*   Trying 34.121.222.176:80...\n* Connected to 34.121.222.176 (34.121.222.176) port 80\n&gt; GET / HTTP/1.1\n&gt; Host: 34.121.222.176\n&gt; User-Agent: curl/8.7.1\n&gt; Accept: */*\n&gt;\n* Request completely sent off\n&lt; HTTP/1.1 404 Not Found\n&lt; date: Tue, 07 May 2024 23:39:35 GMT\n&lt; content-length: 0\n&lt;\n* Connection #0 to host 34.121.222.176 left intact\n</code></pre> <p>Why do we get a 404 (Not Found)?</p>"},{"location":"shared-gw/","title":"Shared Gateway","text":"<p>Deploy a second workload and a second route associated to the same gateway</p> <pre><code>kubectl apply -f apps/customers.yaml -f apps/web-frontend.yaml\n</code></pre>"},{"location":"shared-gw/#configure-the-route","title":"Configure the route","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: web-frontend\nspec:\n  hostnames:\n  - customers-frontend.esuez.org\n  parentRefs:\n  - name: eg\n  rules:\n  - backendRefs:\n    - name: web-frontend\n      port: 80\n</code></pre> <pre><code>kubectl apply -f shared-gw/web-frontend-route.yaml\n</code></pre>"},{"location":"shared-gw/#verify","title":"Verify","text":"<p>After the DNS entry is created, verify that the route is reachable:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl http://customers-frontend.esuez.org/\n</code></pre> <pre><code>curl http://customers-frontend.esuez.org/ --resolve customers-frontend.esuez.org:80:$GATEWAY_IP\n</code></pre>"},{"location":"shared-gw/#inspect-route-configuration","title":"Inspect route configuration","text":"<pre><code>egctl config envoy-proxy route -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=default \\\n  -o yaml | bat -l yaml\n</code></pre> <p>Here is a slightly sanitized copy of the captured output:</p> <pre><code>envoy-gateway-system:\n  envoy-default-eg-e41e7b31-59b4dd766f-sf78k:\n    dynamicRouteConfigs:\n    - routeConfig:\n        name: default/eg/http\n        virtualHosts:\n        - domains:\n          - httpbin.esuez.org\n          name: default/eg/http/httpbin_esuez_org\n          routes:\n          - match:\n              prefix: /\n            name: httproute/default/httpbin/rule/0/match/0/httpbin_esuez_org\n            route:\n              cluster: httproute/default/httpbin/rule/0\n        - domains:\n          - customers-frontend.esuez.org\n          name: default/eg/http/customers-frontend_esuez_org\n          routes:\n          - match:\n              prefix: /\n            name: httproute/default/web-frontend/rule/0/match/0/customers-frontend_esuez_org\n            route:\n              cluster: httproute/default/web-frontend/rule/0\n</code></pre>"},{"location":"simple-route/","title":"Simple routing","text":""},{"location":"simple-route/#deploy-a-workload","title":"Deploy a workload","text":"<pre><code>kubectl apply -f apps/httpbin.yaml\n</code></pre>"},{"location":"simple-route/#deploy-an-httproute-to-httpbin","title":"Deploy an HTTPRoute to <code>httpbin</code>","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin\nspec:\n  hostnames:\n  - httpbin.esuez.org\n  parentRefs:\n  - name: eg\n  rules:\n  - backendRefs:\n    - name: httpbin\n      port: 8000\n</code></pre> <pre><code>kubectl apply -f simple-route/httpbin-route.yaml\n</code></pre>"},{"location":"simple-route/#verify","title":"Verify","text":"<p>After the DNS entry is created for the hostname specified in the HTTPRoute, try to access the app:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl http://httpbin.esuez.org/json\n</code></pre> <pre><code>curl http://httpbin.esuez.org/json --resolve httpbin.esuez.org:80:$GATEWAY_IP\n</code></pre>"},{"location":"snippets/","title":"Snippets","text":"<p>Capture the Gateway IP address for the gateway named <code>eg</code>:</p> <pre><code>export GATEWAY_IP=$(kubectl get gtw eg -o jsonpath='{.status.addresses[0].value}')\n</code></pre>"},{"location":"takeaways/","title":"Takeaways","text":"<ul> <li> <p>Envoy Gateway has come a long way.</p> <p>When Matt Klein announced a collaboration between multiple vendors (Tetrate, Ambassador labs, VMware..) to create an open source foundation for Envoy-based gateway solutions, the project was just getting started.</p> </li> <li> <p>EG recently reached the v1.0 milestone and is now fully conformant implementation of the Kubernetes Gateway API.</p> </li> <li> <p>EG achieves its objective of unlocking the capabilities of envoyproxy, and making it easy to deploy and configure in a cloud-native environment.</p> </li> <li> <p>There's a lot of goodness to unpack.</p> <p>We scratched the surface exploring only a few example scenarios. The Envoy Gateway tasks section provides recipes for dozens of traffic management and security scenarios.</p> </li> <li> <p>This was only an introduction to Envoy Gateway.</p> <p>Besides the various routing and security configuration scenarios, it's important to explore other facets of EG, including operations and observability.</p> </li> </ul>"},{"location":"tls/","title":"TLS","text":"<p>The objective is to configure the Gateway to serve <code>httpbin</code> over TLS.</p>"},{"location":"tls/#deploy-cert-manager","title":"Deploy <code>cert-manager</code>","text":"<p>We decide to let cert-manager manage certificates on our behalf.</p> <pre><code>helm repo add jetstack https://charts.jetstack.io --force-update\nhelm repo update\n</code></pre> <pre><code>helm upgrade --install --create-namespace --namespace cert-manager \\\n  --set installCRDs=true \\\n  --set featureGates=ExperimentalGatewayAPISupport=true \\\n  cert-manager jetstack/cert-manager\n</code></pre>"},{"location":"tls/#create-a-self-signed-issuer","title":"Create a self-signed issuer","text":"<pre><code>---\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: selfsigned\nspec:\n  selfSigned: {}\n</code></pre> <pre><code>kubectl apply -f tls/selfsigned-issuer.yaml\n</code></pre>"},{"location":"tls/#add-an-https-listener","title":"Add an HTTPS listener","text":"<p>Add an HTTPS listener for <code>httpbin.esuez.org</code> hostname on the gateway, configured to terminate TLS:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: eg\n  annotations:\n    cert-manager.io/cluster-issuer: selfsigned\nspec:\n  gatewayClassName: eg\n  listeners:\n  - name: http\n    protocol: HTTP\n    port: 80\n  - name: https\n    protocol: HTTPS\n    port: 443\n    hostname: httpbin.esuez.org\n    tls:\n      mode: Terminate\n      certificateRefs:\n      - name: httpbin-cert\n</code></pre> <pre><code>kubectl apply -f tls/gateway-add-https.yaml\n</code></pre>"},{"location":"tls/#test-it","title":"Test it","text":"<p>Access httpbin over TLS:</p> Using DNS resolutionUsing <code>curl</code> name resolve flag <pre><code>curl --insecure -v --head https://httpbin.esuez.org/\n</code></pre> <pre><code>curl --insecure -v --head https://httpbin.esuez.org/ \\\n   --resolve httpbin.esuez.org:443:$GATEWAY_IP\n</code></pre>"},{"location":"traffic-split/","title":"Traffic Splitting","text":"<p>This scenario demonstrates traffic splitting:  how the <code>weight</code> field in an HttpRoute can be used to specify the distribution of traffic between two backend references, two services.</p>"},{"location":"traffic-split/#context","title":"Context","text":"<p>The <code>customers</code> service should already be deployed in the default namespace (see Shared Gateway).</p>"},{"location":"traffic-split/#instructions","title":"Instructions","text":"<ol> <li> <p>Deploy <code>customers-v2</code> backing deployment:</p> <pre><code>---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: customers-v2\n  labels:\n    app: customers\n    version: v2\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: customers\n      version: v2\n  template:\n    metadata:\n      labels:\n        app: customers\n        version: v2\n    spec:\n      serviceAccountName: customers\n      containers:\n      - image: gcr.io/tetratelabs/customers:2.0.0\n        imagePullPolicy: Always\n        name: svc\n        ports:\n        - containerPort: 3000\n</code></pre> <pre><code>kubectl apply -f traffic-split/customers-v2.yaml\n</code></pre> </li> <li> <p>Define services for each v1 and v2 subsets:</p> <pre><code>---\napiVersion: v1\nkind: Service\nmetadata:\n  name: customers-v1\nspec:\n  selector:\n    app: customers\n    version: v1\n  ports:\n  - port: 80\n    name: http\n    targetPort: 3000\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: customers-v2\nspec:\n  selector:\n    app: customers\n    version: v2\n  ports:\n  - port: 80\n    name: http\n    targetPort: 3000\n</code></pre> <pre><code>kubectl apply -f traffic-split/customers-subsets.yaml\n</code></pre> </li> <li> <p>Define an HttpRoute that splits traffic 80/20 between v1 and v2:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: customers\nspec:\n  hostnames:\n  - customers.esuez.org\n  parentRefs:\n  - name: eg\n  rules:\n  - backendRefs:\n    - name: customers-v1\n      port: 80\n      weight: 80\n    - name: customers-v2\n      port: 80\n      weight: 20\n</code></pre> <pre><code>kubectl apply -f traffic-split/customers-route.yaml\n</code></pre> </li> </ol>"},{"location":"traffic-split/#test-it","title":"Test it","text":"<p>Send a number of test request to the <code>customers</code> route:</p> <pre><code>for i in {1..10}; do\n  curl http://customers.esuez.org/ --resolve customers.esuez.org:80:$GATEWAY_IP\ndone\n</code></pre> <p>About 80% of requests should go to v1.</p> <p>Responses from the <code>v2</code> service can be distinguished from <code>v1</code> by their payload:  v2 returns customer names and cities, whereas v1 returns only customer names.</p>"},{"location":"wasm/","title":"WebAssembly","text":"<p>Warning</p> <p>The ability to specify wasm extensions will be released in versions 1.1 of Envoy Gateway.</p> <p>You can test it today by ensuring you install Envoy Gateway version \"v0.0.0-latest\" in Setup.</p> <p>In this scenario we demonstrate how to apply a wasm extension to an HttpRoute.</p> <p>You will apply an extension policy that references a simple, pre-built wasm plugin to the HttpRoute for the <code>httpbin</code> sample application.</p> <p>The basic logic of the plugin is to inject arbitrary, configurable headers into HTTP responses on the associated route.</p>"},{"location":"wasm/#context","title":"Context","text":"<p><code>httpbin</code> is already deployed to the <code>default</code> namespace and the simple HttpRoute is already defined for it.</p>"},{"location":"wasm/#instructions","title":"Instructions","text":"<ol> <li> <p>Send a test request to the <code>httpbin</code> route:</p> <pre><code> curl -v http://httpbin.esuez.org/json --resolve httpbin.esuez.org:80:$GATEWAY_IP\n</code></pre> <p>The request should succeed, and return some json.</p> <p>Note the headers in the HTTP response.</p> </li> <li> <p>Review the following extension policy:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: EnvoyExtensionPolicy\nmetadata:\n  name: wasm-plugin\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  wasm:\n  - code:\n      type: Image\n      image:\n        url: us-central1-docker.pkg.dev/eitan-tetrate/misc-repo/wasm:v1\n    config:\n      header_1: my first header\n      header_2: \"yet another header..\"\n</code></pre> <p>Apply the policy:</p> <pre><code>kubectl apply -f wasm/extension-policy.yaml\n</code></pre> </li> <li> <p>Repeat the request:</p> <p><code>shell  curl -v http://httpbin.esuez.org/json --resolve httpbin.esuez.org:80:$GATEWAY_IP</code></p> <p>Note the response headers contain extra headers from the configuration of the wasm plugin.</p> </li> </ol>"}]}